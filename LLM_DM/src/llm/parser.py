"""
Configuration Parser Module

Validates and normalizes configuration JSON generated by LLM.
"""

import json
from typing import Dict, List, Optional, Any
from pathlib import Path


class ConfigValidationError(Exception):
    """Raised when configuration validation fails."""
    pass


class ConfigParser:
    """
    Parser and validator for dataset generation configurations.
    
    Ensures that LLM-generated JSON meets the required schema and
    contains valid values for data generation.
    """
    
    VALID_DISTRIBUTIONS = {"random", "normal", "zipf", "exponential"}
    
    def __init__(self, strict_mode: bool = True):
        """
        Initialize the parser.
        
        Args:
            strict_mode: If True, raise errors on invalid configs.
                        If False, attempt to fix/normalize configs.
        """
        self.strict_mode = strict_mode
    
    def parse(self, config: Dict) -> Dict:
        """
        Parse and validate a configuration dictionary.
        
        Args:
            config: Raw configuration from LLM
        
        Returns:
            Validated and normalized configuration
        
        Raises:
            ConfigValidationError: If validation fails in strict mode
        """
        validated = {}
        
        # Validate dataset_meta
        validated["dataset_meta"] = self._validate_dataset_meta(
            config.get("dataset_meta", {})
        )
        
        # Validate distribution_config
        validated["distribution_config"] = self._validate_distribution_config(
            config.get("distribution_config", {})
        )
        
        # Validate pattern_injection
        validated["pattern_injection"] = self._validate_pattern_injection(
            config.get("pattern_injection", [])
        )
        
        return validated
    
    def _validate_dataset_meta(self, meta: Dict) -> Dict:
        """Validate dataset metadata section."""
        validated = {}
        
        # num_transactions (required)
        num_trans = meta.get("num_transactions")
        if num_trans is None:
            if self.strict_mode:
                raise ConfigValidationError("num_transactions is required")
            num_trans = 1000  # default
        
        if not isinstance(num_trans, int) or num_trans <= 0:
            raise ConfigValidationError(
                f"num_transactions must be positive integer, got {num_trans}"
            )
        validated["num_transactions"] = num_trans
        
        # num_items (required)
        num_items = meta.get("num_items")
        if num_items is None:
            if self.strict_mode:
                raise ConfigValidationError("num_items is required")
            num_items = 100  # default
        
        if not isinstance(num_items, int) or num_items <= 0:
            raise ConfigValidationError(
                f"num_items must be positive integer, got {num_items}"
            )
        validated["num_items"] = num_items
        
        # density (optional, 0.0-1.0)
        density = meta.get("density", 0.1)
        if not (0.0 <= density <= 1.0):
            raise ConfigValidationError(
                f"density must be between 0.0 and 1.0, got {density}"
            )
        validated["density"] = float(density)
        
        # avg_transaction_len (optional)
        avg_len = meta.get("avg_transaction_len")
        if avg_len is not None:
            if not isinstance(avg_len, int) or avg_len <= 0:
                raise ConfigValidationError(
                    f"avg_transaction_len must be positive integer or null, got {avg_len}"
                )
            validated["avg_transaction_len"] = avg_len
        else:
            # Calculate from density if not provided
            validated["avg_transaction_len"] = int(num_items * density)
        
        return validated
    
    def _validate_distribution_config(self, dist: Dict) -> Dict:
        """Validate distribution configuration."""
        validated = {}
        
        # method (required)
        method = dist.get("method", "zipf")
        if method not in self.VALID_DISTRIBUTIONS:
            if self.strict_mode:
                raise ConfigValidationError(
                    f"Invalid distribution method '{method}'. "
                    f"Valid options: {self.VALID_DISTRIBUTIONS}"
                )
            method = "zipf"  # fallback
        validated["method"] = method
        
        # params (depends on method)
        params = dist.get("params", {})
        validated["params"] = self._validate_distribution_params(method, params)
        
        return validated
    
    def _validate_distribution_params(self, method: str, params: Dict) -> Dict:
        """Validate distribution-specific parameters."""
        validated = {}
        
        if method == "zipf":
            alpha = params.get("alpha", 1.1)
            if not (0.0 < alpha < 10.0):
                raise ConfigValidationError(
                    f"zipf alpha must be between 0 and 10, got {alpha}"
                )
            validated["alpha"] = float(alpha)
        
        elif method == "normal":
            mean = params.get("mean", 0.5)
            std = params.get("std", 0.2)
            validated["mean"] = float(mean)
            validated["std"] = float(std)
        
        elif method == "exponential":
            scale = params.get("scale", 1.0)
            validated["scale"] = float(scale)
        
        # "random" has no params
        
        return validated
    
    def _validate_pattern_injection(self, patterns: List[Dict]) -> List[Dict]:
        """Validate pattern injection list."""
        validated = []
        
        if not isinstance(patterns, list):
            raise ConfigValidationError("pattern_injection must be a list")
        
        for i, pattern in enumerate(patterns):
            try:
                validated.append(self._validate_single_pattern(pattern, i))
            except ConfigValidationError as e:
                if self.strict_mode:
                    raise
                # Skip invalid pattern in non-strict mode
                print(f"Warning: Skipping invalid pattern {i}: {e}")
        
        return validated
    
    def _validate_single_pattern(self, pattern: Dict, index: int) -> Dict:
        """Validate a single pattern definition."""
        validated = {}
        
        # id (optional)
        validated["id"] = pattern.get("id", f"pattern_{index}")
        
        # items (required, list of integers)
        items = pattern.get("items")
        if not items or not isinstance(items, list):
            raise ConfigValidationError(f"Pattern {index}: items must be a non-empty list")
        
        if not all(isinstance(x, int) and x >= 0 for x in items):
            raise ConfigValidationError(
                f"Pattern {index}: all items must be non-negative integers"
            )
        
        # Remove duplicates while preserving order
        seen = set()
        unique_items = []
        for item in items:
            if item not in seen:
                seen.add(item)
                unique_items.append(item)
        validated["items"] = unique_items
        
        # target_support (required, 0.0-1.0)
        support = pattern.get("target_support")
        if support is None:
            raise ConfigValidationError(f"Pattern {index}: target_support is required")
        
        if not (0.0 < support <= 1.0):
            raise ConfigValidationError(
                f"Pattern {index}: target_support must be between 0 and 1, got {support}"
            )
        validated["target_support"] = float(support)
        
        # noise_ratio (optional, 0.0-1.0)
        noise = pattern.get("noise_ratio", 0.0)
        if not (0.0 <= noise < 1.0):
            raise ConfigValidationError(
                f"Pattern {index}: noise_ratio must be between 0 and 1, got {noise}"
            )
        validated["noise_ratio"] = float(noise)
        
        return validated
    
    @staticmethod
    def from_file(filepath: str, strict_mode: bool = True) -> Dict:
        """
        Load and parse configuration from a JSON file.
        
        Args:
            filepath: Path to JSON configuration file
            strict_mode: Whether to use strict validation
        
        Returns:
            Validated configuration dictionary
        """
        with open(filepath, "r", encoding="utf-8") as f:
            config = json.load(f)
        
        parser = ConfigParser(strict_mode=strict_mode)
        return parser.parse(config)
    
    @staticmethod
    def to_file(config: Dict, filepath: str):
        """
        Save configuration to a JSON file.
        
        Args:
            config: Configuration dictionary
            filepath: Output file path
        """
        Path(filepath).parent.mkdir(parents=True, exist_ok=True)
        with open(filepath, "w", encoding="utf-8") as f:
            json.dump(config, f, indent=2, ensure_ascii=False)


if __name__ == "__main__":
    # Test with example config
    test_config = {
        "dataset_meta": {
            "num_transactions": 1000,
            "num_items": 100,
            "density": 0.1
        },
        "distribution_config": {
            "method": "zipf",
            "params": {"alpha": 1.2}
        },
        "pattern_injection": [
            {
                "id": "test_pattern",
                "items": [1, 5, 10],
                "target_support": 0.05,
                "noise_ratio": 0.1
            }
        ]
    }
    
    parser = ConfigParser()
    validated = parser.parse(test_config)
    print("Validated configuration:")
    print(json.dumps(validated, indent=2))
